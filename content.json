{"posts":[{"title":"Android AIDL 解析","text":"编译器做了什么 通过查看编译后产生的Java文件，观察其结构 构造后的AIDL类产生了一个同名接口，这个接口包含了AIDL内声明的所有方法，并且继承了android.os.IInterface。接口包含了两个静态类： class Default class Stub Default类默认实现了AIDL接口以及IInterface的asBinder()方法，但都为空实现。 StubStub类为具体的AIDL实现类，继承了android.os.Binder类，并实现AIDL接口，接下来看下这个类的结构以及这个类都做了些什么工作。 构造函数。构造函数将AIDL接口与Binder通过一个描述符关联起来，在Binder中，这个attachInterface()是这么描述自身功能的： 将特定的接口与Binder绑定（其实就是内部变量持有了这个AIDL接口），当调用这个函数之后，使用queryLocalInterface()函数将会返回与Binder绑定的IInterface，即为编译器实现好的AIDL接口的实现类。 一个静态方法，将Binder转换为IInterface，即我们的AIDL接口，其实就是从Binder中查找Binder是否关联了与描述符相等的IInterface接口： 123456public @Nullable IInterface queryLocalInterface(@NonNull String descriptor) { if (mDescriptor != null &amp;&amp; mDescriptor.equals(descriptor)) { return mOwner; } return null;} 如果本地的Binder已经与我们的AIDL接口实现绑定了之后，就直接返回AIDL的实现类，否则，就需要通过代理（这个代理本身也实现了AIDL接口）来连接到Binder。 asBinder()方法。返回Binder本身。 onTransact()方法。 onTransact()方法就是实现进程间通信的关键方法。这个方法需要四个参数。一个是整型的code，表示需要调用的方法。第二个参数为data，表示远程调用中传入的参数。第三个参数为reply，表示执行后返回的数据。第四个参数为flags，这个参数传入其父类Binder的onTransact方法中，表示RPC的类型。 在onTransact()方法中，如果调用的是AIDL中的方法的时候，就会将返回数据写入reply中。 Stub.Proxy。Proxy实现了AIDL接口，其中的AIDL方法是在将参数数据写入data之后，就调用Binder的transact方法，transact方法其实就是调用了onTransact()方法。","link":"/2022/04/14/Android_AIDL/"},{"title":"Android.bp 代码 overlay 的一些问题","text":"起因之前由于业务上需要，需要按照不同的配置项给同一个项目打包出两个不同的产物（有点类似于渠道包，不过比渠道包复杂得多）。 示例假如有一个项目，你需要从源码中获取某个标识符，来确定打包的渠道，你需要在源码编译时候去决定打包的内容。当然，具体场景肯定没这么简单，是包含了大量具体的复杂逻辑执行的。于是你创建一个项目，包含了如下的代码: 12345678910├── src│ └── com│ └── gitofleonardo│ └── overlaytest│ ├── BaseIdentifierRetrieverImpl.java│ ├── DomesticIdentifier.java│ ├── IdentifierRetrieverImpl.java│ ├── IIdentifier.java│ ├── IIdentifierRetriever.java│ └── MainActivity.java IIdentifier 为一个标识符接口，用来返回具体的标识符： 123public interface IIdentifier { String getIdentifier();} IIdentifierRetriever 为用来获取这个标识符实现的接口： 123public interface IIdentifierRetriever { IIdentifier retrieverID();} 然后，有一个用于国内渠道的标识符实现： 123456public class DomesticIdentifier implements IIdentifier { @Override public String getIdentifier() { return &quot;DomesticID&quot;; }} 并且配备了相应的 retriever 来获取这个标识符实例： 123456public class BaseIdentifierRetrieverImpl implements IIdentifierRetriever { @Override public DomesticIdentifier retrieverID() { return new DomesticIdentifier(); }} 最后，IdentifierRetrieverImpl 是你在使用时的具体实现： 12public class IdentifierRetrieverImpl extends BaseIdentifierRetrieverImpl {} 你需要在 MainActivity 中通过 IdentifierRetrieverImpl 来获取当前打包的标识符： 123IdentifierRetrieverImpl retriever = new IdentifierRetrieverImpl();String data = retriever.retrieverID().getIdentifier();Log.i(TAG, data); 这样一来，你在使用的时候，就不需要关心 IdentifierRetrieverImpl 内部具体是怎么实现的，不需要关心编译的是什么 target。 你只需要配置 Android.bp 来添加编译 target 就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445filegroup { name : &quot;overlay-test-src&quot;, srcs : [ &quot;src/**/*.java&quot;, &quot;src/**/*.kt&quot;, ],}android_library { name : &quot;OverlayTestResLib&quot;, srcs : [], resource_dirs : [&quot;res&quot;], static_libs : [ &quot;com.google.android.material_material&quot;, ], manifest : &quot;AndroidManifest.xml&quot;, sdk_version : &quot;current&quot;, min_sdk_version : min_overlaytest_sdk_version,}android_library { name : &quot;OverlayTestLib&quot;, srcs : [ &quot;:overlay-test-src&quot;, ], static_libs : [ &quot;OverlayTestResLib&quot;, ], platform_apis : true, min_sdk_version : min_overlaytest_sdk_version, sdk_version : &quot;current&quot;}android_app { name : &quot;HhvvgOverlayTest&quot;, static_libs : [ &quot;OverlayTestLib&quot;, ], optimize: { enabled: false, }, sdk_version : &quot;current&quot;, min_sdk_version : min_overlaytest_sdk_version, target_sdk_version: &quot;current&quot;, system_ext_specific: true,} 通过 make HhvvgOverlayTest -j$(nproc) 即可得到产物。 添加海外产物这时候，由于业务需要，你需要添加海外的标识符，以供海外的版本使用。这时候，你将国内跟海外的拆分成两个不同的 build target： 123456789101112├── src_build_domestic│ └── com│ └── gitofleonardo│ └── overlaytest│ ├── BaseIdentifierRetrieverImpl.java│ └── DomesticIdentifier.java└── src_build_overseas └── com └── gitofleonardo └── overlaytest ├── BaseIdentifierRetrieverImpl.java └── OverseasIdentifier.java 各自的 BaseIdentifierImpl 分别返回各自的 IIdentifier 类型。对 Android.bp稍加修改，即可实现这种需求： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273filegroup { name : &quot;overlay-test-src_domestic&quot;, srcs : [ &quot;src_build_domestic/**/*.java&quot;, &quot;src_build_domestic/**/*.kt&quot;, ],}filegroup { name : &quot;overlay-test-src_overseas&quot;, srcs : [ &quot;src_build_overseas/**/*.java&quot;, &quot;src_build_overseas/**/*.kt&quot;, ],}//-------------------- Domestic target -----------------------//android_library { name : &quot;OverlayTestDomesticLib&quot;, srcs : [ &quot;:overlay-test-src&quot;, &quot;:overlay-test-src_domestic&quot;, ], static_libs : [ &quot;OverlayTestResLib&quot;, ], platform_apis : true, min_sdk_version : min_overlaytest_sdk_version, sdk_version : &quot;current&quot;}android_app { name : &quot;HhvvgOverlayTestDomestic&quot;, static_libs : [ &quot;OverlayTestDomesticLib&quot;, ], optimize: { enabled: false, }, sdk_version : &quot;current&quot;, min_sdk_version : min_overlaytest_sdk_version, target_sdk_version: &quot;current&quot;, system_ext_specific: true,}//-------------------- Overseas target -----------------------//android_library { name : &quot;OverlayTestOverseasLib&quot;, srcs : [ &quot;:overlay-test-src&quot;, &quot;:overlay-test-src_overseas&quot;, ], static_libs : [ &quot;OverlayTestResLib&quot;, ], platform_apis : true, min_sdk_version : min_overlaytest_sdk_version, sdk_version : &quot;current&quot;}android_app { name : &quot;HhvvgOverlayTestOverseas&quot;, static_libs : [ &quot;OverlayTestOverseasLib&quot;, ], optimize: { enabled: false, }, sdk_version : &quot;current&quot;, min_sdk_version : min_overlaytest_sdk_version, target_sdk_version: &quot;current&quot;, system_ext_specific: true,} 一切都很顺利，运行起来功能正常没有问题。 12345// target HhvvgOverlayTestDomestic log outputMainActivity com.gitofleonardo.overlaytest I DomesticID// target HhvvgOverlayTestOverseas log outputMainActivity com.gitofleonardo.overlaytest I OverseasID 于是你高高兴兴去找组长 review 合入，但组长说这个目录是不是有点太复杂了，可不可以简化下，直接在编译命令入手，让另一个 target 去合并入原本的 target 源码中，并亲自给你改了一版： 12345678910111213141516android_app { name : &quot;HhvvgOverlayTestOverseas&quot;, static_libs : [ &quot;OverlayTestDomesticLib&quot;, ], srcs : [ &quot;:overlay-test-src_overseas&quot;, ], optimize: { enabled: false, }, sdk_version : &quot;current&quot;, min_sdk_version : min_overlaytest_sdk_version, target_sdk_version: &quot;current&quot;, system_ext_specific: true,} 这样就只需要给 overlay-test-src_overseas 新建目录就可以了，编译的时候由 overlay-test-src_overseas 去覆盖原本的 OverlayTestDomesticLib 中的源码。编译成功了，但是同时运行也报错了： 1234567891011121314151617181920Process: com.gitofleonardo.overlaytest, PID: 2727java.lang.NoSuchMethodError: No virtual method retrieverID()Lcom/gitofleonardo/overlaytest/DomesticIdentifier; in class Lcom/gitofleonardo/overlaytest/IdentifierRetrieverImpl; or its super classes (declaration of 'com.gitofleonardo.overlaytest.IdentifierRetrieverImpl' appears in /data/app/~~UtmhUdACU8iRHNhrZ-8jzQ==/com.gitofleonardo.overlaytest-mtnkYfyBNu-ke2cIpPxowA==/base.apk) at com.gitofleonardo.overlaytest.MainActivity.onCreate(MainActivity.java:23) at android.app.Activity.performCreate(Activity.java:9079) at android.app.Activity.performCreate(Activity.java:9057) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1531) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4188) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4393) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:222) at android.app.servertransaction.TransactionExecutor.executeNonLifecycleItem(TransactionExecutor.java:133) at android.app.servertransaction.TransactionExecutor.executeTransactionItems(TransactionExecutor.java:103) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:80) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2773) at android.os.Handler.dispatchMessage(Handler.java:109) at android.os.Looper.loopOnce(Looper.java:232) at android.os.Looper.loop(Looper.java:317) at android.app.ActivityThread.main(ActivityThread.java:8934) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911) 居然报 no virtual method，编译的时候不是好好的吗？于是抱着怀疑的心情反编译看了下产物。 123IdentifierRetrieverImpl retriever = new IdentifierRetrieverImpl();String data = retriever.retrieverID().getIdentifier();Log.i(TAG, data); 这不是跟源码里的一模一样吗，怎么会报错呢。我们来看一下具体报错信息：No virtual method retrieverID()Lcom/gitofleonardo/overlaytest/DomesticIdentifier; in class Lcom/gitofleonardo/overlaytest/IdentifierRetrieverImpl;，不对啊，我们编译的不是 overseas 版本的吗，为什么他会去调用 DomesticIdentifier retrieverID() 方法呢？看一下 BaseIdentifierRetrieverImpl，确实没错啊： 12345678/* loaded from: classes.dex */public class BaseIdentifierRetrieverImpl implements IIdentifierRetriever { /* JADX DEBUG: Method merged with bridge method: retrieverID()Lcom/gitofleonardo/overlaytest/IIdentifier; */ @Override // com.gitofleonardo.overlaytest.IIdentifierRetriever public OverseasIdentifier retrieverID() { return new OverseasIdentifier(); }} 但随后看了一下 MainActivity 的 smali 产物，恍然大悟： 12.local v0, &quot;retriever&quot;:Lcom/gitofleonardo/overlaytest/IdentifierRetrieverImpl;invoke-virtual {v0}, Lcom/gitofleonardo/overlaytest/IdentifierRetrieverImpl;-&gt;retrieverID()Lcom/gitofleonardo/overlaytest/DomesticIdentifier; 反编译的源码中看不出来是调用了 DomesticIdentifier retrieverID()，但是 smali 中确实就是调用的这个方法。还记得编译 HhvvgOverlayTestOverseas 的源码依赖是怎么写的吗： 123456static_libs : [ &quot;OverlayTestDomesticLib&quot;,],srcs : [ &quot;:overlay-test-src_overseas&quot;,], 没错，上面由于 HhvvgOverlayTestOverseas 依赖的是 OverlayTestDomesticLib，所以 OverlayTestDomesticLib 会先进行编译，编译的时候由于 BaseIdentifierRetrieverImpl 的 retrieveID 方法返回了 DomesticIdentifier，所以 MainActivity 中的 invokevirtual 也是调用的这个方法。然后才编译的 :overlay-test-src_overseas 并替换原有同名产物，但此时 MainActivity 位于 OverlayTestDomesticLib 中，已经编译好了，不会再修改。 看来这种方法行不通，于是我的代码就顺理成章地合入了。 取消方法覆写返回子类有人可能会说了，主播主播，你这不就是因为 domestic 的 BaseIdentifierRetrieverImpl 返回类型返回了 IIdentifier 的具体子类吗，你直接声明返回 IIdentifier 不就可以了吗？诶，你还真是个小机灵鬼，这确实可以，只需要进行如下修改： 123456public class BaseIdentifierRetrieverImpl implements IIdentifierRetriever { @Override public IIdentifier retrieverID() { return new DomesticIdentifier(); }} 代码立马就可以跑了，但，这真是你想要的吗？某些业务确实是明确知道会返回这一个子类，如果只是返回的超类，则还需要额外增加类型判断。并且，随着业务复杂度的上升，可能不仅仅有方法调用，万一到时候有常量调用，被编译器内联优化了怎么办呢？这些未知性对于业务来说算得上是一个潜在的风险，不应冒这种风险来做一个不必要的改动。 渠道包行为对比没写过渠道包，了解不多，一直从事的系统应用开发，后续看心情更新吧。","link":"/2025/03/16/Android_bp_overlay/"},{"title":"ViewRootImpl#applyTransactionOnDraw 的坑","text":"前情提要之前在帮一同事做 SurfaceView 相关的内容（他本人对 SurfaceControl 相关接口不太熟悉）。在即将解决需要使用到帧同步接口的时候， 无意间看到了 SurfaceView 使用到了 ViewRootImpl#applyTransactionOnDraw 来做帧同步内容。 123456789private void applyTransactionOnVriDraw(Transaction t) { final ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null) { // If we are using BLAST, merge the transaction with the viewroot buffer transaction. viewRoot.applyTransactionOnDraw(t); } else { t.apply(); }} 我一看好啊，以前老是写这种代码来做帧同步： 123viewRoot.registerRtFrameCallback(frame -&gt; { viewRoot.mergeWithNextTransaction(t, frame);}); 虽然不怎么麻烦，但是贯彻简洁主义的我是这样想的：两次方法调用 &lt; 一次方法调用。于是在简单看了下这接口的实现之后就决定以后就用这接口了。 遇到的问题后面在做桌面动画需求的时候，鉴于我喜欢偷懒，于是也直接使用了这个接口来同步动画结束时的 finishTransaction。但在测试频繁打断动画的时候 却发现了动画结束的时候居然会闪一下，看着就像没帧同步的样子（信念崩塌）。 于是赶紧去仔细看了下这个接口的实现，好家伙，原来这接口只是保证了 Transaction 一定能生效，但可能是通过帧同步生效的，并不一定。 具体是怎么合并到 BLASTBufferQueue 的，可以自行看一下 ViewRootImpl#registerCallbacksForSync 这个方法，我们只需要看帧同步不生效的原因就行了： 1234567891011121314151617181920// 具体在 ViewRootImpl#performTraversal 里if (!cancelAndRedraw) { mReportNextDraw = false; mLastReportNextDrawReason = null; mActiveSurfaceSyncGroup = null; if (mHasPendingTransactions) { // TODO: We shouldn't ever actually hit this, it means mPendingTransaction wasn't // merged with a sync group or BLASTBufferQueue before making it to this point // But better a one or two frame flicker than steady-state broken from dropping // whatever is in this transaction mPendingTransaction.apply(); mHasPendingTransactions = false; } mSyncBuffer = false; if (isInWMSRequestedSync()) { mWmsRequestSyncGroup.markSyncReady(); mWmsRequestSyncGroup = null; mWmsRequestSyncGroupState = WMS_SYNC_NONE; }} 好嘛，安排得明明白白，注释都写好了：为了避免事务状态丢失，提前调用 apply，闪一两帧总好过状态不对。 结尾能怎么办，老实用回之前一直在用的帧同步方法呗。不过以后用这些接口的时候，还是得好好看下注释，没有注释就看下具体实现，避免再出现这种踩坑的问题。","link":"/2025/05/27/Android_caution_applyTransactionOnDraw/"},{"title":"从零开始给 Surface 实现帧同步","text":"背景参与系统开发的工程师应该都比较清楚，很多时候我们用 Surface 相关功能并不是使用 SurfaceView 的，而是自己创建一个 Surface，这样 Surface 的可定制程度就可以很高。有的需求需要做到使 Transaction 跟 Surface 里面绘制的内容的位置等几何信息进行同步（例如 ViewRootImpl 本身也是直接使用 Surface 来绘制，也是自行实现了一套帧同步逻辑）。 但遗憾的是，Surface 本身只提供了绘制等基础功能，本身并不存在帧同步的实现。那么，我们可以参照 ViewRootImpl 以及 SurfaceView 的帧同步实现来给单独的 Surface 实现帧同步功能。 具体实现要想实现帧同步，首先就要了解基础的帧同步原理。这个大体上是比较好理解的，主要分为以下几个流程。 监听帧可用回调 通过 BLASTBufferQueue 合并事务 上面两个流程已经是简化过的了，接下来通过代码来具体讲解是如何实现的。 初始化必要组件首先，需要知道我们需要用到哪些类，Surface、BLASTBufferQueue 是必不可少的两个，这两个是一开始创建 Surface 就创建好的，如果你不知道如何使用 BLASTBufferQueue，可以参考 SurfaceView#createBlastSurfaceControls(ViewRootImpl, String, Transaction)。 与 BLAST 相关的接口，除了 BLASTBufferQueue 除了能做帧同步外，通过 setBLASTLayer 来声明创建的 Surface，可以做到背景模糊等功能。BLASTBufferQueue 也需要通过 BLAST Layer 来创建。 1234567891011public class LayerRootImpl { private final Surface mSurface; private final BLASTBufferQueue mBLASTBufferQueue; public LayerRootImpl(Surface surface, BLASTBufferQueue blastBufferQueue) { mSurface = surface; mBLASTBufferQueue = blastBufferQueue; } ...} 实现帧回调监听如何实现帧回调监听呢？诶，框架刚好就实现了一个类 HardwareRenderer 来做这件事。 1234567...private final HardwareRenderer mRenderer;...mRenderer = new HardwareRenderer();mRenderer.setSurface(surface);... 然后可以通过 HardwareRenderer#setFrameCallback(HardwareRenderer.FrameDrawingCallback) 来注册帧回调监听了，是不是看着很简单。 但实际上，还有一个地方是需要注意的，就是什么时候去注册这个监听回调呢？先看下 BLASTBufferQueue 的 mergeWithNextTransaction 方法，有两个参数，一个是 Transaction 本身，一个是 frameNumber，也就是需要同步的帧号。也就是说，我们是需要知道事务要具体跟哪一帧合并。但肯定不是跟过去的帧，而是跟未来要合成的帧，其实在大多数情况下都是需要下一帧去合并的（为什么是大多数呢？因为我也不知道会有哪些奇葩的需求）。 因此 setFrameCallback 这个接口肯定是需要在绘制前去调用的，这一点可以在 ThreadedRenderer#updateRootDisplayList(View, ThreadedRenderer.DrawCallbacks) 处求证，没错，我们熟知的 ViewRootImpl 的帧同步也是通过这个方法实现的。 在这里，我们可以仿照 Surface，创建一个 HwuiContext 类，来维护管理 Canvas 的生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102private final class HwuiContext { /** * 用来绘制生成 {@link Canvas} 的 {@link RenderNode} */ private final RenderNode mRenderNode; /** * 监听帧回调需要用到 */ private HardwareRenderer mHardwareRenderer; /** * 当前用于绘制的 {@link Canvas} */ private RecordingCanvas mCanvas; /** * 在绘制前需要注册的所有帧回调 */ private List&lt;HardwareRenderer.FrameDrawingCallback&gt; mCallbacks; HwuiContext() { mRenderNode = RenderNode.create(&quot;HwuiCanvas&quot;, null); mRenderNode.setClipToBounds(false); mRenderNode.setForceDarkAllowed(false); mHardwareRenderer = new HardwareRenderer(); // 关联 RenderNode mHardwareRenderer.setContentRoot(mRenderNode); // 关联 Surface mHardwareRenderer.setSurface(mSurface, true); mHardwareRenderer.setLightSourceAlpha(0.0f, 0.0f); mHardwareRenderer.setLightSourceGeometry(0.0f, 0.0f, 0.0f, 0.0f); } Canvas lockCanvas(int width, int height) { if (mCanvas != null) { throw new IllegalStateException(&quot;Surface was already locked!&quot;); } mCanvas = mRenderNode.beginRecording(width, height); return mCanvas; } void unlockAndPost(Canvas canvas) { if (canvas != mCanvas) { throw new IllegalArgumentException(&quot;canvas object must be the same instance that &quot; + &quot;was previously returned by lockCanvas&quot;); } mRenderNode.endRecording(); mCanvas = null; // 在这里即将开始绘制前设置帧回调 setupFrameCallbacks(); // 转到 RenderThread 请求 GPU 绘制 mHardwareRenderer.createRenderRequest() .setVsyncTime(System.nanoTime()) .syncAndDraw(); } private void setupFrameCallbacks() { // 收集所有之前注册好的监听回调 List&lt;HardwareRenderer.FrameDrawingCallback&gt; frameCallbacks = mCallbacks; mCallbacks = null; if (frameCallbacks == null || frameCallbacks.isEmpty()) { return; } mHardwareRenderer.setFrameCallback(new HardwareRenderer.FrameDrawingCallback() { @Override public void onFrameDraw(long frame) { } @Override public HardwareRenderer.FrameCommitCallback onFrameDraw(int syncResult, long frame) { ArrayList&lt;HardwareRenderer.FrameCommitCallback&gt; frameCommitCallbacks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; frameCallbacks.size(); ++i) { // 这里就能拿到用于传入 BLASTBufferQueue 的 frameNumber 了，也就是下一帧送往 // SurfaceFlinger 合成的帧号。 HardwareRenderer.FrameCommitCallback frameCommitCallback = frameCallbacks.get(i).onFrameDraw(syncResult, frame); if (frameCommitCallback != null) { frameCommitCallbacks.add(frameCommitCallback); } } if (frameCommitCallbacks.isEmpty()) { return null; } return didProduceBuffer -&gt; { for (int i = 0; i &lt; frameCommitCallbacks.size(); ++i) { frameCommitCallbacks.get(i).onFrameCommit(didProduceBuffer); } }; } }); } void destroy() { mHardwareRenderer.destroy(); }} 然后对外暴露注册帧回调的接口： 123456public void registerRtFrameCallback(HardwareRenderer.FrameDrawingCallback callback) { if (mHwuiContext.mCallbacks == null) { mHwuiContext.mCallbacks = new ArrayList&lt;&gt;(); } mHwuiContext.mCallbacks.add(callback);} 以及向 BLASTBufferQueue 合并事务的接口： 123public void mergeWithNextTransaction(SurfaceControl.Transaction t, long frameNumber) { mBLASTBufferQueue.mergeWithNextTransaction(t, frameNumber);} 绘制以及监听经过上面的步骤之后其实以及几乎完工了，最后就是使用示例而已了。 12345678910111213141516171819202122232425262728293031323334353637public class LayerRootImplTest { private final SurfaceControl mSurfaceControl; private final SurfaceControl mBlastSurfaceControl; private final BLASTBufferQueue mBlastBufferQueue; private final Surface mSurface; private final LayerRootImpl mLayerRootImpl; public LayerRootImplTest(View rootView, int width, int height, int format) { // 创建 Surface SurfaceSession session = new SurfaceSession(); mSurfaceControl = new SurfaceControl.Builder(session) .setName(&quot;test-surface&quot;) .setParent(rootView.getViewRootImpl().getSurfaceControl()) .setCallsite(&quot;SurfaceView.updateSurface&quot;) .setContainerLayer() .build(); mBlastSurfaceControl = new SurfaceControl.Builder(session) .setName(&quot;test-surface(BLAST)&quot;) .setParent(mSurfaceControl) .setHidden(false) .setBLASTLayer() .setCallsite(&quot;SurfaceView.updateSurface&quot;) .build(); mBlastBufferQueue = new BLASTBufferQueue(&quot;test-blast-queue&quot;, false /* updateDestinationFrame */); mBlastBufferQueue.update(mBlastSurfaceControl, width, height, format); mSurface = new Surface(); mSurface.copyFrom(mBlastBufferQueue); // 创建 LayerRootImpl mLayerRootImpl = new LayerRootImpl(mSurface, mBlastBufferQueue); } public void testSync(SurfaceControl.Transaction t) { mLayerRootImpl.registerRtFrameCallback(frame -&gt; mLayerRootImpl.mergeWithNextTransaction(t, frame)); }} 出乎意料的简单。 完整代码LayerRootImpl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package com.example;import android.graphics.BLASTBufferQueue;import android.graphics.Canvas;import android.graphics.HardwareRenderer;import android.graphics.RecordingCanvas;import android.graphics.RenderNode;import android.view.Surface;import android.view.SurfaceControl;import java.util.ArrayList;import java.util.List;public class LayerRootImpl { private final Surface mSurface; private final BLASTBufferQueue mBLASTBufferQueue; private final HwuiContext mHwuiContext; public LayerRootImpl(Surface surface, BLASTBufferQueue blastBufferQueue) { mSurface = surface; mBLASTBufferQueue = blastBufferQueue; mHwuiContext = new HwuiContext(); } public void registerRtFrameCallback(HardwareRenderer.FrameDrawingCallback callback) { if (mHwuiContext.mCallbacks == null) { mHwuiContext.mCallbacks = new ArrayList&lt;&gt;(); } mHwuiContext.mCallbacks.add(callback); } public void mergeWithNextTransaction(SurfaceControl.Transaction t, long frameNumber) { mBLASTBufferQueue.mergeWithNextTransaction(t, frameNumber); } private final class HwuiContext { /** * 用来绘制生成 {@link Canvas} 的 {@link RenderNode} */ private final RenderNode mRenderNode; /** * 监听帧回调需要用到 */ private final HardwareRenderer mHardwareRenderer; /** * 当前用于绘制的 {@link Canvas} */ private RecordingCanvas mCanvas; /** * 在绘制前需要注册的所有帧回调 */ private List&lt;HardwareRenderer.FrameDrawingCallback&gt; mCallbacks; HwuiContext() { mRenderNode = RenderNode.create(&quot;HwuiCanvas&quot;, null); mRenderNode.setClipToBounds(false); mRenderNode.setForceDarkAllowed(false); mHardwareRenderer = new HardwareRenderer(); // 关联 RenderNode mHardwareRenderer.setContentRoot(mRenderNode); // 关联 Surface mHardwareRenderer.setSurface(mSurface, true); mHardwareRenderer.setLightSourceAlpha(0.0f, 0.0f); mHardwareRenderer.setLightSourceGeometry(0.0f, 0.0f, 0.0f, 0.0f); } Canvas lockCanvas(int width, int height) { if (mCanvas != null) { throw new IllegalStateException(&quot;Surface was already locked!&quot;); } mCanvas = mRenderNode.beginRecording(width, height); return mCanvas; } void unlockAndPost(Canvas canvas) { if (canvas != mCanvas) { throw new IllegalArgumentException(&quot;canvas object must be the same instance that &quot; + &quot;was previously returned by lockCanvas&quot;); } mRenderNode.endRecording(); mCanvas = null; // 在这里即将开始绘制前设置帧回调 setupFrameCallbacks(); // 转到 RenderThread 请求 GPU 绘制 mHardwareRenderer.createRenderRequest() .setVsyncTime(System.nanoTime()) .syncAndDraw(); } private void setupFrameCallbacks() { // 收集所有之前注册好的监听回调 List&lt;HardwareRenderer.FrameDrawingCallback&gt; frameCallbacks = mCallbacks; mCallbacks = null; if (frameCallbacks == null || frameCallbacks.isEmpty()) { return; } mHardwareRenderer.setFrameCallback(new HardwareRenderer.FrameDrawingCallback() { @Override public void onFrameDraw(long frame) { } @Override public HardwareRenderer.FrameCommitCallback onFrameDraw(int syncResult, long frame) { ArrayList&lt;HardwareRenderer.FrameCommitCallback&gt; frameCommitCallbacks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; frameCallbacks.size(); ++i) { // 这里就能拿到用于传入 BLASTBufferQueue 的 frameNumber 了，也就是下一帧送往 // SurfaceFlinger 合成的帧号。 HardwareRenderer.FrameCommitCallback frameCommitCallback = frameCallbacks.get(i).onFrameDraw(syncResult, frame); if (frameCommitCallback != null) { frameCommitCallbacks.add(frameCommitCallback); } } if (frameCommitCallbacks.isEmpty()) { return null; } return didProduceBuffer -&gt; { for (int i = 0; i &lt; frameCommitCallbacks.size(); ++i) { frameCommitCallbacks.get(i).onFrameCommit(didProduceBuffer); } }; } }); } void destroy() { mHardwareRenderer.destroy(); } }} LayerRootImplTest: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example;import android.graphics.BLASTBufferQueue;import android.view.Surface;import android.view.SurfaceControl;import android.view.SurfaceSession;import android.view.View;public class LayerRootImplTest { private final SurfaceControl mSurfaceControl; private final SurfaceControl mBlastSurfaceControl; private final BLASTBufferQueue mBlastBufferQueue; private final Surface mSurface; private final LayerRootImpl mLayerRootImpl; public LayerRootImplTest(View rootView, int width, int height, int format) { // 创建 Surface SurfaceSession session = new SurfaceSession(); mSurfaceControl = new SurfaceControl.Builder(session) .setName(&quot;test-surface&quot;) .setParent(rootView.getViewRootImpl().getSurfaceControl()) .setCallsite(&quot;SurfaceView.updateSurface&quot;) .setContainerLayer() .build(); mBlastSurfaceControl = new SurfaceControl.Builder(session) .setName(&quot;test-surface(BLAST)&quot;) .setParent(mSurfaceControl) .setHidden(false) .setBLASTLayer() .setCallsite(&quot;SurfaceView.updateSurface&quot;) .build(); mBlastBufferQueue = new BLASTBufferQueue(&quot;test-blast-queue&quot;, false /* updateDestinationFrame */); mBlastBufferQueue.update(mBlastSurfaceControl, width, height, format); mSurface = new Surface(); mSurface.copyFrom(mBlastBufferQueue); // 创建 LayerRootImpl mLayerRootImpl = new LayerRootImpl(mSurface, mBlastBufferQueue); } public void testSync(SurfaceControl.Transaction t) { mLayerRootImpl.registerRtFrameCallback(frame -&gt; mLayerRootImpl.mergeWithNextTransaction(t, frame)); }}","link":"/2025/06/17/Android_frame_sync_impl/"},{"title":"Android Framework 单编","text":"关于 Android11 下单编 Framework 的问题在 Android 11 下，不知道为什么原本我在 Android 6.0 下使用的 mm 出现了错误（会把 test 也一并编译，导致问题），因此更换为下面的命令： make -j16 SystemUI make -j16 framework or make -j16framework-minus-apex make -j16 services","link":"/2022/04/14/Android_framework_make/"},{"title":"不要再用 binder 跨进程同步 ui 了","text":"前言最近在搞低端机上的性能优化，碰上一堆头疼的问题。有一个特别坑的玩意，那就是谷歌自己写的一套绝世“好代码“，用户手机上经常用到的负一屏的基础架构。本来我两年前开始搞这玩意的时候觉得没啥，滚动同步 UI 嘛，而且还要跨进程，那看起来 binder 通信不就是不二之选：桌面滚动到边缘触发 EdgeEffect，EdgeEffect 来通过 binder 通知负一屏滚动了多少，然后负一屏那边在回调真正的滚动进度回桌面。这一套行云流水的操作下来可以说是没什么问题吧，至少其他厂家也在用，谷歌自己也在用。 但是啊，但是，坑爹的来了，这一套在高端机上没啥问题，高端机性能好嘛，我之前也是一直在搞高端机的需求开发，低端机接触得不多（或者说没接触过）。当跑在低端机上的时候，问题就开始显现出来了。倒也不是出在 binder 的问题上，手机再卡，oneway binder 其实也不会耗费多长时间（至少我是没遇到过 oneway binder 长耗时的情况）。问题是什么呢，就是通过这种方式衔接滚动时，桌面跟负一屏之间并不存在帧同步。尤其在低端机上，GPU 的性能本身就不太好，很容易出现 buffer 堆积在 SurfaceFlinger 端的问题。如果桌面跟负一屏这两个进程的 buffer 一个正常渲染，而另一个出现堆积比较严重的情况时，会有什么现象呢？那当然是两者的 UI 并不会渲染为相同的进度，毕竟对于同一滚动进度而言，一个已经渲染好了送往 SurfaceFlinger 合成，另一个还苦苦卡在 dequeueBuffer 等待拿到 buffer 去调用 GPU 渲染。 该怎么办呢最佳解决方案当然还是利用到 BLASTBufferQueue 的帧同步，毕竟谷歌出这玩意不是白出的，目前大量的场景都有用到，包括我正在负责的桌面应用窗口动画。BLASTBufferQueue 的细节我就先不深究了，只需要知道它是先 dequeueBuffer 获取缓冲区，然后调用 GPU 进行绘制合成，最后通过 mergePendingTransactions 把之前合并进来的事务一块发往 SurfaceFlinger 渲染就可以了。为什么能做到帧同步呢，就是因为它把事务跟 buffer 相关的事务是一块发往 SurfaceFlinger 端的，都一块发送了，那当然是一块合成的了。 但这玩意也不是谁都会用谁都能用好的，需要知道什么时候去合并事务。之前我另一个同事有一个需求，需要对一个 Surface 进行几何变化操作，搞了几天实在是搞不定，就来找我了。其实本身也不是什么很难的问题，就是生成事务的时间节点不对。仔细想想 ViewRootImpl 的 vsync 处理流程，它是先去处理 MotionEvent，然后做动画，最后才去 performTraversal 来遍历 View 树然后合成。使用 BLASTBufferQueue 一个很经典的用法就是： 123viewRootImpl.registerRtFrameCallback(frame -&gt; { viewRootImpl.mergeWithNextTransaction(t, frame)}) 调用 registerRtFrameCallback 会往 ThreadedRenderer 里面注册 FrameDrawingCallback，每次帧绘制完成之后就会回调到这里，而且在 ThreadedRenderer#updateRootDisplayList 里面会收集这些回调，并通过 setFrameCallback 来设置回调监听。也就是说，你在 ThreadedRenderer#updateRootDisplayList 之后调用的 registerRtFrameCallback，只能等到下下帧才会被收集。因此，你要想在当前帧的 View 相对应的位置去映射一个相关的位置到 Transaction （例如通过 Matrix 设置）的话，那么你调用 registerRtFrameCallback 就只能在绘制流程之前去调用，不然你这次 transaction 就没法合并进即将到来的下一帧里。 回到原来的问题你问我卡顿最后怎么解决的？那当然是没解决了，谁家好人会换方案，线程加速加速又不是不能用。 当然了，我还是希望能更换目前的负一屏方案的，谷歌那套该扫进垃圾桶了，现在有 SurfaceControlViewHost 能跨进程渲染的，好用不伤脑，而且还能拿到 SurfaceControl 来确保可以做到帧同步。 求求你换方案吧，只要是我能做到的我什么都愿意做（你这个人真是满脑子只想着自己呢）","link":"/2025/03/20/Android_plz_do_not_use_binder_to_sync_ui/"},{"title":"Android 各版本适配点","text":"Android M 6.0增加了运行时的权限申请 Android N 7.0强制执行 StrictMode API，Intent 的 Uri 中 scheme 不能为 file 类型。如果要共享文件，需要使用 content:// 类型的 data。如果要共享文件，则使用 FileProvider。 官方 FileProvider 说明 官方是这么说明 FileProvider 的： FileProvider 是 ContentProvider 的一个特殊子类，方便了应用间的安全的应用内文件共享，通过创建一个 content:// 的 Uri 而不是一个 file:// 类型的Uri。 使用 FileProvider 需要经过以下的几个步骤： 声明一个 FileProvider 确定可用的文件 获取文件的 Uri 为 Uri 授予临时权限 把 Uri 提供给其他应用 官方说明：在授权的时候，需要注意的是如果设备的运行 API 级别位于 Android 4.1 （API Level 16）与 Android 5.1（API Level 22）之间，需要创建一个 ClipData 对象，并为这个 ClipData 对象授予权限 123shareContentIntent.setClipData(ClipData.newRawUri(&quot;&quot;, contentUri));shareContentIntent.addFlags( Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); Android O 8.0Android 8.0 引入了通知 Channel，允许为要显示的每种通知类型创建用户可自定义的渠道。 后台限制执行现在，在 Manifest 里面注册的广播接收器无法在后台使用。 未知软件源限制Android 8.0 移除了“允许未知来源”的开关。如果想安装应用，则需要申请权限 1&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt; 注意：这里申请权限需要跳转到“允许安装未知应用”界面进行授权 12Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES);startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP); Android P 9.0Http请求失败9.0 中的默认禁止了 Http 请求，需要改用 Https。可以添加网络配置： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 然后在 Manifest 中声明： 1android:networkSecurityConfig=&quot;network_security_config&quot; 可以指定特定域名： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;!-- Android 9.0 上部分域名时使用 http --&gt; &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;secure.example.com&lt;/domain&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;cdn.example1.com&lt;/domain&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 前台服务想创建前台服务，需要申请 FOREGROUND_SERVICE 权限 设备序列号在 Android 9 中，调用 Build.SERIAL 会始终返回 UNKNOWN 以保护用户的隐私。如果你的应用需要访问设备的硬件序列号，那么需要先请求 READ_PHONE_STATE 权限，然后调用 Build.getSerial Android Q 10文件的存储Android 10 的文件存储机制改为了沙盒模式，只能访问自己目录下的文件和公共媒体文件，但是 10 以下的机型还是使用的老式的文件存储方式。 应用私有目录应用的外部私有目录对应 /Android/data/package_name/，内部对应了 /data/data/package_name。应用的私有目录文件访问方式与之前的版本保持一致，不需要改动。 共享目录包含媒体文件、文档以及其他文件。 共享目录需要通过 MediaStore API 或者 Storage Access Framework 的方式访问。 MediaStore API 在共享目录下创建文件或者访问应用自己创建的文件，是不需要申请存储权限的。 MediaStore API 访问其他应用在共享目录下创建的文件，需要申请存储权限，否则通过 ContentResolver 查询不到文件的Uri。 MediaStore API 不能访问其他应用创建的非媒体文件，如 pdf、office、doc、txt 等，只能通过 Storage Access Framework 方式访问。 如果应用还未完成适配工作，可以暂时让应用以兼容模式运行，需要在 Manifest 中声明： 1android:requestLegacyExternalStorage=&quot;true&quot; 然后在代码中判断是否是兼容模式： 1Environment.isExternalStorageLegacy() 存储访问框架 调用存储相关操作的 Intent； 用户看到系统选择器，供其浏览文档提供其并选择将执行存储文件相关的位置或文档； 应用获得对代表用户所选位置或文档的 Uri 的读写访问权限。 但是发现一个不方便的地方：如果采用 Storage Access Framework 的话，保存文件的时候只能通过打开窗口来选择保存的地方，不能直接在后台完成所有操作。 如果是在 10.0 之前的话，应该可以直接通过访问文件来读写文件，只要获取了写权限。但是现在 10 之后，不需要写权限了，各个应用是拥有沙箱机制的。 定位权限如果需要使用后台位置权限，则需要声明新的权限 ACCESS_BACKGROUND_LOCATION。 媒体文件位置权限图片之类的文件会带有位置信息，而这个信息是敏感的。在 Android 10 之后如果要访问媒体位置，则需要声明 ACCESS_MEDIA_LOCATION 权限。 Android R 11分区存储从 Android 11 开始执行强制分区存储机制，之前 Android 10 中声明的 android:requestLegacyExternalStorage=&quot;true&quot; 已经不起作用了。 另外，Android 11 允许使用除了 MediaStore API 之外的 API 通过文件路径直接访问存储空间中的媒体文件，包括： File API 原生库，如 fopen() 单次权限授予就是短时间内授予用户权限。 请求位置权限Android 11 中取消了“始终允许”这一选项，也就是不会授予后台访问位置权限。建议递增位置权限请求，比如先请求前台的权限，再在某一需要的时候请求后台权限。 软件包可见性新特性，用于限制其他软件获取用户当前安装的软件信息。 前台服务类型如果需要在前台访问位置信息，则需要在 Manifest 中声明相应的前台服务类型。 权限自动重置如果用户的应用经过数个月的时间没有使用的话，那么系统就会自动清除该应用的运行时数据来保护用户的隐私。 读取手机号如果要读取手机号的话，需要在Manifest中声明 READ_PHONE_STATE 权限。","link":"/2022/04/14/Android_versions_adaptation/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"}],"categories":[],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}